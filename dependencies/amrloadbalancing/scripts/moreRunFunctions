#---------------------------------*- sh -*-------------------------------------
# =========                 |
# \\      /  F ield         | foam-extend: Open Source CFD
#  \\    /   O peration     | Version:     4.0
#   \\  /    A nd           | Web:         http://www.foam-extend.org
#    \\/     M anipulation  | For copyright notice see file Copyright
#------------------------------------------------------------------------------
# License
#     This file is part of foam-extend.
#
#     foam-extend is free software: you can redistribute it and/or modify it
#     under the terms of the GNU General Public License as published by the
#     Free Software Foundation, either version 3 of the License, or (at your
#     option) any later version.
#
#     foam-extend is distributed in the hope that it will be useful, but
#     WITHOUT ANY WARRANTY; without even the implied warranty of
#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#     General Public License for more details.
#
#     You should have received a copy of the GNU General Public License
#     along with foam-extend.  If not, see <http://www.gnu.org/licenses/>.
#
# Script
#     RunFunctions
#
# Description
#     Run Functions optimized for use with Load-Balanced AMR classes
#
# Example
#     # Choose where to backup dynamicMeshDict
#     backup=constant/dynamicMeshDict.$(date +"%s")
#
#     # Enable refinement, disable unrefinement, and record maxRefinementLevel
#     maxRefinement=$(setDynamicMeshDictForMeshUpdate $backup)
#
#     # It's nice to trap ctrl-c here so you don't end up with backup files
#     trap "onCtrl_C $backup" INT
#
#     # Do mesh updates ... etc, and then
#     # Reset to original dynamicMeshDict
#     resetDynamicMeshDict $backup
#
#------------------------------------------------------------------------------

stripComments()
{
    # Get a clean version of $1 if gcc is available
    # $1: OpenFOAM dictionary to operate on
    # $2: Backup name

    cp $1 $2
    # In case the dict has some code blocks
    sed -i 's_#{_codeBeginPlaceHolder_g' $2
    sed -i 's_#};_codeEndPlaceHolder_g' $2
    if command -v gcc &> /dev/null
    then
        # Strip comments
        gcc -fpreprocessed -dD -x c++ -P -E $2 -o $1
    fi
    sed -i 's_codeBeginPlaceHolder_#{_g' $1 $2
    sed -i 's_codeEndPlaceHolder_#};_g' $1 $2
}


getMaxRefinementLevels()
{
    awk -v m=-100 '/maxRefinementLevel *[0-9]+;/{ if ($2>m){m=$2}} END{print m}' constant/dynamicMeshDict | tr -d ";"
}

setIntervalsForMeshUpdate()
{
    # Enables all refinements, disables all unrefinements
    sed -i -e "s/refineInterval .*;/refineInterval 1;/g" constant/dynamicMeshDict
    sed -i -e "s/unrefineInterval .*;/unrefineInterval 1000;/g" constant/dynamicMeshDict
}

setDynamicMeshDictForMeshUpdate()
{
    stripComments constant/dynamicMeshDict $1 > /dev/null
    setIntervalsForMeshUpdate
    getMaxRefinementLevels
}

resetDynamicMeshDict()
{
    cp $1 constant/dynamicMeshDict
    rm $1
}

onCtrl_C() {
    resetDynamicMeshDict $1
    exit 1
}

getNumberOfProcessors()
{
    suffix=$(date +"%s")
    stripComments system/decomposeParDict system/decomposeParDict.$suffix > /dev/null
    grep -oP 'numberOfSubdomains *\K[0-9]+' system/decomposeParDict
    cp system/decomposeParDict.$suffix system/decomposeParDict
    rm system/decomposeParDict.$suffix
}

getApplication()
{
    sed -ne 's/^ *application\s*\([a-zA-Z]*\)\s*;.*$/\1/p' system/controlDict
}

runApplication()
{
    APP_RUN=
    LOG_IGNORE=false
    LOG_APPEND=false
    LOG_SUFFIX=

    # Parse options and executable
    while [ $# -gt 0 ] && [ -z "$APP_RUN" ]; do
        key="$1"
        case "$key" in
            -append|-a)
                LOG_IGNORE=true
                LOG_APPEND=true
                ;;
            -overwrite|-o)
                LOG_IGNORE=true
                ;;
            -suffix|-s)
                LOG_SUFFIX=".$2"
                shift
                ;;
            *)
                APP_RUN="$key"
                APP_NAME="${key##*/}"
                LOG_SUFFIX="${APP_NAME}${LOG_SUFFIX}"
                ;;
        esac

        shift
    done

    if [ -f log.$LOG_SUFFIX ] && [ "$LOG_IGNORE" = "false" ]
    then
        echo "$APP_NAME already run on $PWD:" \
             "remove log file 'log.$LOG_SUFFIX' to re-run"
    else
        echo "Running $APP_RUN on $PWD"
        if [ "$LOG_APPEND" = "true" ]; then
            $APP_RUN "$@" >> log.$LOG_SUFFIX 2>&1
        else
            $APP_RUN "$@" > log.$LOG_SUFFIX 2>&1
        fi
    fi
}

runParallel()
{
    APP_RUN=
    LOG_IGNORE=false
    LOG_APPEND=false
    LOG_SUFFIX=
    nProcs=$(getNumberOfProcessors)

    # Parse options and executable
    while [ $# -gt 0 ] && [ -z "$APP_RUN" ]; do
        key="$1"
        case "$key" in
            -append|-a)
                LOG_IGNORE=true
                LOG_APPEND=true
                ;;
            -overwrite|-o)
                LOG_IGNORE=true
                ;;
            -suffix|-s)
                LOG_SUFFIX=".$2"
                shift
                ;;
            -np|-n)
                nProcs="$2"
                shift
                ;;
            *)
                APP_RUN="$key"
                APP_NAME="${key##*/}"
                LOG_SUFFIX="${APP_NAME}${LOG_SUFFIX}"
                ;;
        esac

        shift
    done

    if [ -f log.$LOG_SUFFIX ] && [ "$LOG_IGNORE" = "false" ]
    then
        echo "$APP_NAME already run on $PWD:" \
             "remove log file 'log.$LOG_SUFFIX' to re-run"
    else
        echo "Running $APP_RUN in parallel on $PWD using $nProcs processes"
        if [ "$LOG_APPEND" = "true" ]; then
            ( mpirun -np $nProcs $APP_RUN -parallel "$@" < /dev/null >> log.$LOG_SUFFIX 2>&1 )
        else
            ( mpirun -np $nProcs $APP_RUN -parallel "$@" < /dev/null > log.$LOG_SUFFIX 2>&1 )
        fi
    fi
}
